<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Loki: StrongPtr Ownership policies</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>StrongPtr Ownership policies<br>
<small>
[<a class="el" href="a00218.html">Smart pointers</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for StrongPtr Ownership policies:</div>
<div class="dynsection">
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html">Loki::Private::TwoRefCountInfo</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">LockableTwoRefCountInfo</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00139.html">Loki::TwoRefCounts</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">LockableTwoRefCounts</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00140.html">Loki::TwoRefLinks</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user" compact><dt><b>Terminology</b></dt><dd>These terms are used within this file's comments.<ol type=1>
<li>StrongPtr : Class used to implement both strong and weak pointers. The second template parameter determines if a StrongPtr is weak or strong.</li><li>Strong pointer : A pointer that claims ownership of a shared object. When the last strong copointer dies, the object is destroyed even if there are weak copointers.</li><li>Weak pointer : A pointer that does not own the shared object it points to. It only destroys the shared object if there no strong copointers exist when it dies.</li><li>Copointers : All the pointers that refer to the same shared object. The copointers must have the same ownership policy, but the other policies may be different.</li><li>Pointee : The shared object.</li></ol>
</dd></dl>
<dl class="user" compact><dt><b>OwnershipPolicy</b></dt><dd>The ownership policy has the pointer to the actual object, and it also keeps track of the strong and weak copointers so that it can know if any strong copointers remain. The plain pointer it maintains is stored as a void pointer, which allows the ownership policy classes to be monolithic classes instead of template classes. As monolithic classes, they reduce amount of code-bloat.</dd></dl>
<dl class="user" compact><dt><b>Writing Your Own OwnershipPolicy</b></dt><dd>If you write your own policy, you must implement these 12 functions:<ol type=1>
<li>explicit YourPolicy( bool strong )</li><li>YourPolicy( void * p, bool strong )</li><li>YourPolicy( const YourPolicy &amp; rhs, bool strong )</li><li>bool Release( bool strong )</li><li>void Increment( bool strong )</li><li>bool Decrement( bool strong )</li><li>bool HasStrongPointer( void ) const</li><li>void Swap( YourPolicy &amp; rhs )</li><li>void SetPointer( void * p )</li><li>void ZapPointer( void )</li><li>void * GetPointer( void ) const</li><li>void * &amp; GetPointerRef( void ) const It is strongly recommended that all 12 of these functions be protected instead of public. These two functions are optional for single-threaded policies, but required for multi-threaded policies:</li><li>void Lock( void ) const</li><li>void Unlock( void ) const This function is entirely optional:</li><li>bool Merge( TwoRefLinks &amp; rhs )</li></ol>
</dd></dl>
<dl class="user" compact><dt><b>DeletePolicy</b></dt><dd>The delete policy provides a mechanism to destroy an object and a default value for an uninitialized pointer. You can override this policy with your own when using the Singleton, NullObject, or Prototype design patterns.</dd></dl>
<dl class="user" compact><dt><b>Writing Your Own DeletePolicy</b></dt><dd>If you write your own policy, you must implement these 3 functions:<ol type=1>
<li>void static Delete( const P * p )</li><li>static P * Default( void )</li><li>void Swap( YourResetPolicy &amp; )</li></ol>
</dd></dl>
<dl class="user" compact><dt><b>ResetPolicy</b></dt><dd>A reset policy tells the ReleaseAll and ResetAll functions whether they should release or reset the StrongPtr copointers. These functions do not affect just one StrongPtr, but all copointers. That is unlike SmartPtr where the Release and Reset functions only affect 1 SmartPtr, and leave all copointers untouched. A useful trick you can do with the ResetPolicy is to not allow reset when a strong pointer exists, and then use the NoCheck policy for all strong pointers. The reset policy guarantees the strong pointers always have a valid pointee, so checking is not required; but weak pointers may still require checking.</dd></dl>
<dl class="user" compact><dt><b>Writing Your Own ResetPolicy</b></dt><dd>If you write your own policy, you must implement these 2 functions:<ol type=1>
<li>bool OnReleaseAll( bool ) const</li><li>bool OnResetAll( bool ) const The bool parameter means that this was called with a strong pointer or one of its copointers is strong. The return value means the pointer can be reset or released. </li></ol>
</dd></dl>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jan 29 18:51:41 2009 for Loki by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
