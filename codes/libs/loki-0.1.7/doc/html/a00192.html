<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Loki: Loki Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Loki Namespace Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">LokiAllocator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html">SimplePointer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">No encaspulation : returns the pointer.  <a href="a00118.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">NeverCreate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Never allows creation. Testing purposes only.  <a href="a00085.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html">AlwaysCreate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always allows creation.  <a href="a00005.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">RateLimitedCreation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limit in rate.  <a href="a00101.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html">AmountLimitedCreation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limit by number of objects.  <a href="a00006.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">EvictLRU</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evicts least accessed objects first.  <a href="a00053.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">EvictAging</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LRU aware of the time span of use.  <a href="a00052.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">EvictRandom</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evicts a random object.  <a href="a00054.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">NoStatisticPolicy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do nothing.  <a href="a00091.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html">SimpleStatisticPolicy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple statistics.  <a href="a00119.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">CachedFactory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00055.html">Factory</a> with caching support.  <a href="a00014.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">CheckForNoThrow</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">CheckForNoChange</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">CheckForNoChangeOrThrow</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">CheckForEquality</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">CheckForNothing</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">ContractChecker</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">CheckStaticForNoThrow</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">CheckStaticForNothing</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html">StaticChecker</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">CheckReturn</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">DontPropagateConst</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">PropagateConst</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">DefaultFactoryError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default policy that throws an exception.  <a href="a00036.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">Factory</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">CloneFactory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy from a polymorphic object.  <a href="a00026.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00064.html">Functor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">BinderFirst</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">Chainer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html">Key</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html">LevelMutexInfo</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html">ThrowOnAnyMutexError</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html">ThrowOnBadDesignMutexError</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">AssertAnyMutexError</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">AssertBadDesignMutexError</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00067.html">JustReturnMutexError</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">NoMutexWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00084.html">MutexSleepWaits</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">SpinLevelMutex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">SleepLevelMutex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html">LevelMutex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">MutexException</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">MutexLocker</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">MultiMutexLocker</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">LockingPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">ConstPropPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">Pimpl</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">RefToValue</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">RegisterOnCreateSet</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00141.html">UnRegisterOnDeleteSet</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html">SafeBitConst</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">ScopeGuardImplBase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html">ScopeGuardImpl0</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html">ScopeGuardImpl1</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">ScopeGuardImpl2</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00114.html">ScopeGuardImpl3</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">ScopeGuardImpl4</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html">ScopeGuardImpl5</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html">ObjScopeGuardImpl0</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">ObjScopeGuardImpl1</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html">ObjScopeGuardImpl2</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">ObjScopeGuardImpl3</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">CreateUsingNew</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">CreateUsing</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">CreateUsingMalloc</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">CreateStatic</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">DefaultLifetime</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">PhoenixSingleton</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">DeletableSingleton</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">SingletonWithLongevity</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">NoDestroy</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">FollowIntoDeath</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">SingletonHolder</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">Singleton</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">SmallObjAllocator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">AllocatorSingleton</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">SmallObjectBase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html">SmallObject</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">SmallValueObject</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">HeapStorage</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">DefaultSPStorage</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">LockedStorage</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">ArrayStorage</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">RefCounted</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">COMRefCounted</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">DeepCopy</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00104.html">RefLinked</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html">DestructiveCopy</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">NoCopy</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">AllowConversion</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html">DisallowConversion</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">NoCheck</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">AssertCheck</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">AssertCheckStrict</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html">NullPointerException</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html">RejectNullStatic</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html">RejectNull</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">RejectNullStrict</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00132.html">SmartPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">FunctionStorage</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the StoragePolicy used by <a class="el" href="a00132.html">SmartPtr</a>.  <a href="a00063.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00131.html">SmartPointer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulate the object in a <a class="el" href="a00132.html">SmartPtr</a> with <a class="el" href="a00063.html" title="Implementation of the StoragePolicy used by SmartPtr.">FunctionStorage</a> policy.  <a href="a00131.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">DeleteUsingFree</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">DeleteNothing</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">DeleteSingle</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">DeleteArray</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">CantResetWithStrong</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">AllowReset</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">NeverReset</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00139.html">TwoRefCounts</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00140.html">TwoRefLinks</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">StrongPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">Mutex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">SingleThreaded</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">BaseVisitor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">CyclicVisitor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">Chunk</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">FixedAllocator</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00192.html#283454c89a3b507c74f05bb038daa173">operator==</a> (const <a class="el" href="a00078.html">LokiAllocator</a>&lt; Type &gt; &amp;, const <a class="el" href="a00078.html">LokiAllocator</a>&lt; Type &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00192.html#a5a779d50d4d4a37aa3664e5a9f01681">operator!=</a> (const <a class="el" href="a00078.html">LokiAllocator</a>&lt; Type &gt; &amp;, const <a class="el" href="a00078.html">LokiAllocator</a>&lt; Type &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Fctor &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Private::BinderFirstTraits<br class="typebreak">
&lt; Fctor &gt;::BoundFunctorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00208.html#g73955e915d2ef0cc231bb6ac5765e812">BindFirst</a> (const Fctor &amp;fun, typename Fctor::Parm1 bound)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Fun1 , class Fun2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Fun2&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00208.html#g1a74f9db98f84037e15dff40ca82d8cc">Chain</a> (const Fun1 &amp;fun1, const Fun2 &amp;fun2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#9548795d9cda6f227a1e1241ba577ca8">GetCurrentThreadsLevel</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#ed0bb857431a808474a4b817d5c37f1c">CountMutexesInCurrentThread</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#ae4c5edaad45b3657f39e8cdbae0f928">CountLocksInCurrentThread</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#8cb767d3e7aaf2fe44b8f3b90218b876">CountMutexesAtCurrentLevel</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">MutexErrors::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html#d633ca81ae0befaf235ae63886368037">DoMutexesMatchContainer</a> (const <a class="el" href="a00071.html#76a0315d91234f5066c75660a9f27a7f">LevelMutexInfo::MutexContainer</a> &amp;mutexes)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00105.html">RefToValue</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00211.html#g613ad438c1e0daeec26304c83f340b76">ByRef</a> (T &amp;t)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class t &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00210.html#g14cf89ecf59f8bf3a6d47cdfe5ff389d">RegisterFunction</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class t &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00210.html#g8d2c3c45de75a6829be4f21a2575bacc">UnRegisterFunction</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , typename Destroyer &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00214.html#g82d4520d213b3b9ef2090f5e237874cf">SetLongevity</a> (T *pDynObject, unsigned int longevity, Destroyer d)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;template&lt; class, class &gt; class T, std::size_t C, std::size_t M, std::size_t O, template&lt; class &gt; class L, class X &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00192.html#bd6a1e278e749117c26908963320b02e">GetLongevity</a> (<a class="el" href="a00002.html">AllocatorSingleton</a>&lt; T, C, M, O, L, X &gt; *)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP1, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#gb3333b9378688690b921def21298d2bf">operator==</a> (const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP1 &gt; &amp;lhs, U *rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP1, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#gd6987be67b5ae633a9ca282aa7cbc13b">operator==</a> (U *lhs, const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP1 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#gf30cc0b3f416d8703d4a4534c52b56b4">operator!=</a> (const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP &gt; &amp;lhs, U *rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g2c4d3dae616ecca69b25e3af91927b66">operator!=</a> (U *lhs, const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g19b38e411732f476e3b288ccbd397331">operator&lt;</a> (const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP &gt; &amp;lhs, U *rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#gf8a4e6ef7065932113a924ee9e9fd63a">operator&lt;</a> (U *lhs, const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1e83c8b289a17eaa9341880a8b848c65"></a><!-- doxytag: member="Loki::operator&gt;" ref="g1e83c8b289a17eaa9341880a8b848c65" args="(const SmartPtr&lt; T, OP, CP, KP, SP, CNP &gt; &amp;lhs, U *rhs)" -->
template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g1e83c8b289a17eaa9341880a8b848c65">operator&gt;</a> (const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP &gt; &amp;lhs, U *rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">///////////////////////////////////////////////////////////////////////////// <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g46ee0daec0cef9d50136689d771642b6">operator&gt;</a> (U *lhs, const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#gad6d21d0d77ddc1668f90a115884f8a3">operator&lt;=</a> (const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP &gt; &amp;lhs, U *rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#geae99a03480ac6f8882d1799f8f1606c">operator&lt;=</a> (U *lhs, const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g54b4de5905940e3780e6e64944f74a11">operator&gt;=</a> (const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP &gt; &amp;lhs, U *rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , template&lt; class &gt; class OP, class CP , template&lt; class &gt; class KP, template&lt; class &gt; class SP, template&lt; class &gt; class CNP, typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g5a4d9a68820aeaed1974a236b380fb49">operator&gt;=</a> (U *lhs, const <a class="el" href="a00132.html">SmartPtr</a>&lt; T, OP, CP, KP, SP, CNP &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U , typename T , bool S, class OP , class CP , template&lt; class &gt; class KP, template&lt; class &gt; class RP, template&lt; class &gt; class DP, template&lt; class &gt; class CNP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#gb5a35f4e3da89fb451c36891a96ab244">operator==</a> (const <a class="el" href="a00135.html">StrongPtr</a>&lt; T, S, OP, CP, KP, RP, DP, CNP &gt; &amp;lhs, U *rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U , typename T , bool S, class OP , class CP , template&lt; class &gt; class KP, template&lt; class &gt; class RP, template&lt; class &gt; class DP, template&lt; class &gt; class CNP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g26dc37f18d3112b69b35514b5e1fd749">operator==</a> (U *lhs, const <a class="el" href="a00135.html">StrongPtr</a>&lt; T, S, OP, CP, KP, RP, DP, CNP &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U , typename T , bool S, class OP , class CP , template&lt; class &gt; class KP, template&lt; class &gt; class RP, template&lt; class &gt; class DP, template&lt; class &gt; class CNP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g7c1d35d961854e812b743b22c89f14f8">operator!=</a> (const <a class="el" href="a00135.html">StrongPtr</a>&lt; T, S, OP, CP, KP, RP, DP, CNP &gt; &amp;lhs, U *rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U , typename T , bool S, class OP , class CP , template&lt; class &gt; class KP, template&lt; class &gt; class RP, template&lt; class &gt; class DP, template&lt; class &gt; class CNP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#gd6031d88c8485cea6a6f4a89356e638a">operator!=</a> (U *lhs, const <a class="el" href="a00135.html">StrongPtr</a>&lt; T, S, OP, CP, KP, RP, DP, CNP &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U , typename T , bool S, class OP , class CP , template&lt; class &gt; class KP, template&lt; class &gt; class RP, template&lt; class &gt; class DP, template&lt; class &gt; class CNP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g8408e61306f223b3721f7792c8e172a9">operator&lt;</a> (const <a class="el" href="a00135.html">StrongPtr</a>&lt; T, S, OP, CP, KP, RP, DP, CNP &gt; &amp;lhs, U *rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U , typename T , bool S, class OP , class CP , template&lt; class &gt; class KP, template&lt; class &gt; class RP, template&lt; class &gt; class DP, template&lt; class &gt; class CNP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g7abc768179c277d50bbb59fdee609668">operator&lt;</a> (U *lhs, const <a class="el" href="a00135.html">StrongPtr</a>&lt; T, S, OP, CP, KP, RP, DP, CNP &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U , typename T , bool S, class OP , class CP , template&lt; class &gt; class KP, template&lt; class &gt; class RP, template&lt; class &gt; class DP, template&lt; class &gt; class CNP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g05304aaf9fabf1dda13ddff6146e2fe2">operator&gt;</a> (U *lhs, const <a class="el" href="a00135.html">StrongPtr</a>&lt; T, S, OP, CP, KP, RP, DP, CNP &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U , typename T , bool S, class OP , class CP , template&lt; class &gt; class KP, template&lt; class &gt; class RP, template&lt; class &gt; class DP, template&lt; class &gt; class CNP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g272c9c4d6381679daba26c93ac36a70e">operator&lt;=</a> (const <a class="el" href="a00135.html">StrongPtr</a>&lt; T, S, OP, CP, KP, RP, DP, CNP &gt; &amp;lhs, U *rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U , typename T , bool S, class OP , class CP , template&lt; class &gt; class KP, template&lt; class &gt; class RP, template&lt; class &gt; class DP, template&lt; class &gt; class CNP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g24773dba1237da071b5df66455393f1d">operator&lt;=</a> (U *lhs, const <a class="el" href="a00135.html">StrongPtr</a>&lt; T, S, OP, CP, KP, RP, DP, CNP &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U , typename T , bool S, class OP , class CP , template&lt; class &gt; class KP, template&lt; class &gt; class RP, template&lt; class &gt; class DP, template&lt; class &gt; class CNP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g93341dd134031aede8273376ed13578d">operator&gt;=</a> (const <a class="el" href="a00135.html">StrongPtr</a>&lt; T, S, OP, CP, KP, RP, DP, CNP &gt; &amp;lhs, U *rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U , typename T , bool S, class OP , class CP , template&lt; class &gt; class KP, template&lt; class &gt; class RP, template&lt; class &gt; class DP, template&lt; class &gt; class CNP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00218.html#g239a9b1c4e557388ba4b9c39051c3f4e">operator&gt;=</a> (U *lhs, const <a class="el" href="a00135.html">StrongPtr</a>&lt; T, S, OP, CP, KP, RP, DP, CNP &gt; &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00217.html#g2f0821e243f812a3ae2abfaea51895e8">GetOffset</a> (std::size_t numBytes, std::size_t alignment)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00217.html#g2444c5bff0a61b6751fb5f57e0c7e8c7">DefaultAllocator</a> (std::size_t numBytes, bool doThrow)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00217.html#g1d24bf776342ace8f2004e3a173f6cb3">DefaultDeallocator</a> (void *p)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
All classes of <a class="el" href="a00192.html">Loki</a> are in the <a class="el" href="a00192.html">Loki</a> namespace<p>
This file is intented to be used if you want a <a class="el" href="a00014.html" title="Factory with caching support.">CachedFactory</a> with a <a class="el" href="a00131.html" title="Encapsulate the object in a SmartPtr with FunctionStorage policy.">SmartPointer</a> encapsulation policy. It as been defined in a separate file because of the many introduced dependencies (SmartPtr.h would depend on Functor.h and CachedFactory.h would depend on SmartPtr.h). By defining another header you pay for those extra dependencies only if you need it.<p>
This file defines <a class="el" href="a00063.html" title="Implementation of the StoragePolicy used by SmartPtr.">FunctionStorage</a> a new <a class="el" href="a00131.html" title="Encapsulate the object in a SmartPtr with FunctionStorage policy.">SmartPointer</a> storage policy and <a class="el" href="a00131.html" title="Encapsulate the object in a SmartPtr with FunctionStorage policy.">SmartPointer</a> a new <a class="el" href="a00014.html" title="Factory with caching support.">CachedFactory</a> encapsulation policy. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ae4c5edaad45b3657f39e8cdbae0f928"></a><!-- doxytag: member="Loki::CountLocksInCurrentThread" ref="ae4c5edaad45b3657f39e8cdbae0f928" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Loki::CountLocksInCurrentThread           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns count of how mutexes the current thread locked. The lock count exceeds the number of mutexes locked by current thread if any mutex got locked more than once. Requires O(m) actions where m is the number of mutexes in the thread. Never throws exceptions. 
<p>References <a class="el" href="a00242.html#l00267">Loki::LevelMutexInfo::GetCurrentMutex()</a>, <a class="el" href="a00243.html#l00214">Loki::LevelMutexInfo::GetLockCount()</a>, and <a class="el" href="a00243.html#l00217">Loki::LevelMutexInfo::GetPrevious()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="8cb767d3e7aaf2fe44b8f3b90218b876"></a><!-- doxytag: member="Loki::CountMutexesAtCurrentLevel" ref="8cb767d3e7aaf2fe44b8f3b90218b876" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Loki::CountMutexesAtCurrentLevel           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns count of mutexes locked by current thread which have the same level as GetCurrentThreadsLevel. Requires O(m) actions where m is the number of mutexes in the thread at current level. Never throws exceptions. 
<p>References <a class="el" href="a00242.html#l00267">Loki::LevelMutexInfo::GetCurrentMutex()</a>, <a class="el" href="a00243.html#l00208">Loki::LevelMutexInfo::GetLevel()</a>, and <a class="el" href="a00243.html#l00217">Loki::LevelMutexInfo::GetPrevious()</a>.</p>

<p>Referenced by <a class="el" href="a00242.html#l00184">DoMutexesMatchContainer()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="ed0bb857431a808474a4b817d5c37f1c"></a><!-- doxytag: member="Loki::CountMutexesInCurrentThread" ref="ed0bb857431a808474a4b817d5c37f1c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Loki::CountMutexesInCurrentThread           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns count of how mutexes the current thread locked. Requires O(m) actions where m is the number of mutexes in the thread. Never throws exceptions. 
<p>References <a class="el" href="a00242.html#l00267">Loki::LevelMutexInfo::GetCurrentMutex()</a>, and <a class="el" href="a00243.html#l00217">Loki::LevelMutexInfo::GetPrevious()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="d633ca81ae0befaf235ae63886368037"></a><!-- doxytag: member="Loki::DoMutexesMatchContainer" ref="d633ca81ae0befaf235ae63886368037" args="(const LevelMutexInfo::MutexContainer &amp;mutexes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MutexErrors::Type Loki::DoMutexesMatchContainer           </td>
          <td>(</td>
          <td class="paramtype">const LevelMutexInfo::MutexContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>mutexes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if container of mutexes matches the recently locked mutexes. If they do match, it returns success, otherwise an error condition. 
<p>References <a class="el" href="a00242.html#l00165">CountMutexesAtCurrentLevel()</a>, <a class="el" href="a00242.html#l00129">GetCurrentThreadsLevel()</a>, <a class="el" href="a00243.html#l00208">Loki::LevelMutexInfo::GetLevel()</a>, <a class="el" href="a00242.html#l00594">Loki::LevelMutexInfo::IsRecentLock()</a>, and <a class="el" href="a00243.html#l00154">Loki::LevelMutexInfo::UnlockedLevel</a>.</p>

<p>Referenced by <a class="el" href="a00242.html#l00316">Loki::LevelMutexInfo::MultiLock()</a>, and <a class="el" href="a00242.html#l00479">Loki::LevelMutexInfo::MultiUnlock()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="9548795d9cda6f227a1e1241ba577ca8"></a><!-- doxytag: member="Loki::GetCurrentThreadsLevel" ref="9548795d9cda6f227a1e1241ba577ca8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Loki::GetCurrentThreadsLevel           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns level of most recently locked mutex by this thread, or UnlockedLevel if no mutexes are locked. Runs in constant time, and never throws exceptions. 
<p>References <a class="el" href="a00242.html#l00267">Loki::LevelMutexInfo::GetCurrentMutex()</a>, <a class="el" href="a00243.html#l00208">Loki::LevelMutexInfo::GetLevel()</a>, and <a class="el" href="a00243.html#l00154">Loki::LevelMutexInfo::UnlockedLevel</a>.</p>

<p>Referenced by <a class="el" href="a00242.html#l00184">DoMutexesMatchContainer()</a>, and <a class="el" href="a00242.html#l00316">Loki::LevelMutexInfo::MultiLock()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="bd6a1e278e749117c26908963320b02e"></a><!-- doxytag: member="Loki::GetLongevity" ref="bd6a1e278e749117c26908963320b02e" args="(AllocatorSingleton&lt; T, C, M, O, L, X &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class, class &gt; class T, std::size_t C, std::size_t M, std::size_t O, template&lt; class &gt; class L, class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Loki::GetLongevity           </td>
          <td>(</td>
          <td class="paramtype">AllocatorSingleton&lt; T, C, M, O, L, X &gt; *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This standalone function provides the longevity level for Small-Object Allocators which use the <a class="el" href="a00125.html">Loki::SingletonWithLongevity</a> policy. The <a class="el" href="a00125.html">SingletonWithLongevity</a> class can find this function through argument- dependent lookup.<p>
<dl class="user" compact><dt><b>Longevity Levels</b></dt><dd>No Small-Object Allocator depends on any other Small-Object allocator, so this does not need to calculate dependency levels among allocators, and it returns just a constant. All allocators must live longer than the objects which use the allocators, it must return a longevity level higher than any such object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5a779d50d4d4a37aa3664e5a9f01681"></a><!-- doxytag: member="Loki::operator!=" ref="a5a779d50d4d4a37aa3664e5a9f01681" args="(const LokiAllocator&lt; Type &gt; &amp;, const LokiAllocator&lt; Type &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Loki::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const LokiAllocator&lt; Type &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LokiAllocator&lt; Type &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All inequality operators return false since <a class="el" href="a00078.html">LokiAllocator</a> is basically a monostate design pattern, so all instances of it are identical. 
</div>
</div><p>
<a class="anchor" name="283454c89a3b507c74f05bb038daa173"></a><!-- doxytag: member="Loki::operator==" ref="283454c89a3b507c74f05bb038daa173" args="(const LokiAllocator&lt; Type &gt; &amp;, const LokiAllocator&lt; Type &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Loki::operator==           </td>
          <td>(</td>
          <td class="paramtype">const LokiAllocator&lt; Type &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LokiAllocator&lt; Type &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All equality operators return true since <a class="el" href="a00078.html">LokiAllocator</a> is basically a monostate design pattern, so all instances of it are identical. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jan 29 18:51:42 2009 for Loki by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
