<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Loki: Loki::SmallObjectBase&lt; ThreadingModel, chunkSize, maxSmallObjectSize, objectAlignSize, LifetimePolicy, MutexPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="a00192.html">Loki</a>::<a class="el" href="a00129.html">SmallObjectBase</a>
  </div>
</div>
<div class="contents">
<h1>Loki::SmallObjectBase&lt; ThreadingModel, chunkSize, maxSmallObjectSize, objectAlignSize, LifetimePolicy, MutexPolicy &gt; Class Template Reference<br>
<small>
[<a class="el" href="a00216.html">Small objects</a>]</small>
</h1><!-- doxytag: class="Loki::SmallObjectBase" --><code>#include &lt;SmallObj.h&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Loki::SmallObjectBase&lt; ThreadingModel, chunkSize, maxSmallObjectSize, objectAlignSize, LifetimePolicy, MutexPolicy &gt;:</div>
<div class="dynsection">
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="a00399.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00002.html">AllocatorSingleton</a><br class="typebreak">
&lt; ThreadingModel, chunkSize, <br class="typebreak">
maxSmallObjectSize, <br class="typebreak">
objectAlignSize, <br class="typebreak">
LifetimePolicy &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#d07df1c9ec9c41580e07e32eddcda82d">ObjAllocatorSingleton</a></td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="39f9c8d5b17c09bece34c8a400981970"></a><!-- doxytag: member="Loki::SmallObjectBase::operator new" ref="39f9c8d5b17c09bece34c8a400981970" args="(std::size_t size)" -->
static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#39f9c8d5b17c09bece34c8a400981970">operator new</a> (std::size_t size)  throw ( std::bad_alloc )</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throwing single-object new throws bad_alloc when allocation fails. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d212efa68b48292bf8fd2dd158b49400"></a><!-- doxytag: member="Loki::SmallObjectBase::operator new" ref="d212efa68b48292bf8fd2dd158b49400" args="(std::size_t size, const std::nothrow_t &amp;)" -->
static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#d212efa68b48292bf8fd2dd158b49400">operator new</a> (std::size_t size, const std::nothrow_t &amp;)  throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-throwing single-object new returns NULL if allocation fails. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dbbe1bde0960a38502af0940004d942f"></a><!-- doxytag: member="Loki::SmallObjectBase::operator new" ref="dbbe1bde0960a38502af0940004d942f" args="(std::size_t size, void *place)" -->
static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#dbbe1bde0960a38502af0940004d942f">operator new</a> (std::size_t size, void *place)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Placement single-object new merely calls global placement new. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="698e8b9ebac9df8c03e557c842a59bc5"></a><!-- doxytag: member="Loki::SmallObjectBase::operator delete" ref="698e8b9ebac9df8c03e557c842a59bc5" args="(void *p, std::size_t size)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#698e8b9ebac9df8c03e557c842a59bc5">operator delete</a> (void *p, std::size_t size)  throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Single-object delete. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#b835d84fa8bc1ed3a558dc2e7a7e39ec">operator delete</a> (void *p, const std::nothrow_t &amp;)  throw ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e2da17da13c6c6a0d7e33c9df9eb27f2"></a><!-- doxytag: member="Loki::SmallObjectBase::operator delete" ref="e2da17da13c6c6a0d7e33c9df9eb27f2" args="(void *p, void *place)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html#e2da17da13c6c6a0d7e33c9df9eb27f2">operator delete</a> (void *p, void *place)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Placement single-object delete merely calls global placement delete. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;template&lt; class, class &gt; class ThreadingModel, std::size_t chunkSize, std::size_t maxSmallObjectSize, std::size_t objectAlignSize, template&lt; class &gt; class LifetimePolicy, class MutexPolicy&gt;<br>
 class Loki::SmallObjectBase&lt; ThreadingModel, chunkSize, maxSmallObjectSize, objectAlignSize, LifetimePolicy, MutexPolicy &gt;</h3>

Base class for small object allocation classes. The shared implementation of the new and delete operators are here instead of being duplicated in both <a class="el" href="a00128.html">SmallObject</a> or <a class="el" href="a00130.html">SmallValueObject</a>, later just called Small-Objects. This class is not meant to be used directly by clients, or derived from by clients. Class has no data members so compilers can use Empty-Base-Optimization.<p>
<dl class="user" compact><dt><b>ThreadingModel</b></dt><dd>This class doesn't support ObjectLevelLockable policy for ThreadingModel. The allocator is a singleton, so a per-instance mutex is not necessary. Nor is using ObjectLevelLockable recommended with <a class="el" href="a00124.html">SingletonHolder</a> since the SingletonHolder::MakeInstance function requires a mutex that exists prior to when the object is created - which is not possible if the mutex is inside the object, such as required for ObjectLevelLockable. If you attempt to use ObjectLevelLockable, the compiler will emit errors because it can't use the default constructor in ObjectLevelLockable. If you need a thread-safe allocator, use the ClassLevelLockable policy.</dd></dl>
<dl class="user" compact><dt><b>Lifetime Policy</b></dt><dd></dd></dl>
The <a class="el" href="a00129.html">SmallObjectBase</a> template needs a lifetime policy because it owns a singleton of <a class="el" href="a00127.html">SmallObjAllocator</a> which does all the low level functions. When using a Small-Object in combination with the <a class="el" href="a00124.html">SingletonHolder</a> template you have to choose two lifetimes, that of the Small-Object and that of the singleton. The rule is: The Small-Object lifetime must be greater than the lifetime of the singleton hosting the Small-Object. Violating this rule results in a crash on exit, because the hosting singleton tries to delete the Small-Object which is then already destroyed.<p>
The lifetime policies recommended for use with Small-Objects hosted by a <a class="el" href="a00124.html">SingletonHolder</a> template are<ul>
<li><a class="el" href="a00046.html">LongevityLifetime::DieAsSmallObjectParent</a> / <a class="el" href="a00045.html">LongevityLifetime::DieAsSmallObjectChild</a></li><li><a class="el" href="a00125.html">SingletonWithLongevity</a></li><li><a class="el" href="a00057.html">FollowIntoDeath</a> (not supported by MSVC 7.1)</li><li><a class="el" href="a00089.html">NoDestroy</a></li></ul>
<p>
The default lifetime of Small-Objects is <a class="el" href="a00046.html">LongevityLifetime::DieAsSmallObjectParent</a> to insure that memory is not released before a object with the lifetime <a class="el" href="a00045.html">LongevityLifetime::DieAsSmallObjectChild</a> using that memory is destroyed. The <a class="el" href="a00046.html">LongevityLifetime::DieAsSmallObjectParent</a> lifetime has the highest possible value of a SetLongevity lifetime, so you can use it in combination with your own lifetime not having also the highest possible value.<p>
The <a class="el" href="a00037.html">DefaultLifetime</a> and <a class="el" href="a00097.html">PhoenixSingleton</a> policies are *not* recommended since they can cause the allocator to be destroyed and release memory for singletons hosting a object which inherit from either <a class="el" href="a00128.html">SmallObject</a> or <a class="el" href="a00130.html">SmallValueObject</a>.<p>
<dl class="user" compact><dt><b>Lifetime usage</b></dt><dd></dd></dl>
<ul>
<li><a class="el" href="a00196.html" title="In this namespace are special lifetime policies to manage lifetime dependencies.">LongevityLifetime</a>: The Small-Object has <a class="el" href="a00046.html">LongevityLifetime::DieAsSmallObjectParent</a> policy and the <a class="el" href="a00122.html">Singleton</a> hosting the Small-Object has <a class="el" href="a00045.html">LongevityLifetime::DieAsSmallObjectChild</a>. The child lifetime has a hard coded SetLongevity lifetime which is shorter than the lifetime of the parent, thus the child dies before the parent.</li></ul>
<p>
<ul>
<li>Both Small-Object and <a class="el" href="a00122.html">Singleton</a> use <a class="el" href="a00125.html">SingletonWithLongevity</a> policy. The longevity level for the singleton must be lower than that for the Small-Object. This is why the AllocatorSingleton's GetLongevity function returns the highest value.</li></ul>
<p>
<ul>
<li><a class="el" href="a00057.html">FollowIntoDeath</a> lifetime: The Small-Object has FollowIntoDeath::With&lt;LIFETIME&gt;::AsMasterLiftime policy and the <a class="el" href="a00122.html">Singleton</a> has FollowIntoDeath::AfterMaster&lt;MASTERSINGLETON&gt;::IsDestroyed policy, where you could choose the LIFETIME.</li></ul>
<p>
<ul>
<li>Both Small-Object and <a class="el" href="a00122.html">Singleton</a> use <a class="el" href="a00089.html">NoDestroy</a> policy. Since neither is ever destroyed, the destruction order does not matter. Note: you will get memory leaks!</li></ul>
<p>
<ul>
<li>The Small-Object has <a class="el" href="a00089.html">NoDestroy</a> policy but the <a class="el" href="a00122.html">Singleton</a> has <a class="el" href="a00125.html">SingletonWithLongevity</a> policy. Note: you will get memory leaks!</li></ul>
<p>
You should *not* use <a class="el" href="a00089.html">NoDestroy</a> for the singleton, and then use <a class="el" href="a00125.html">SingletonWithLongevity</a> for the Small-Object.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd></dd></dl>
<ul>
<li>test/SmallObj/SmallSingleton.cpp</li><li>test/Singleton/Dependencies.cpp </li></ul>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="d07df1c9ec9c41580e07e32eddcda82d"></a><!-- doxytag: member="Loki::SmallObjectBase::ObjAllocatorSingleton" ref="d07df1c9ec9c41580e07e32eddcda82d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class, class &gt; class ThreadingModel, std::size_t chunkSize, std::size_t maxSmallObjectSize, std::size_t objectAlignSize, template&lt; class &gt; class LifetimePolicy, class MutexPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00002.html">AllocatorSingleton</a>&lt; ThreadingModel, chunkSize, maxSmallObjectSize, objectAlignSize, LifetimePolicy &gt; <a class="el" href="a00129.html">Loki::SmallObjectBase</a>&lt; ThreadingModel, chunkSize, maxSmallObjectSize, objectAlignSize, LifetimePolicy, MutexPolicy &gt;::<a class="el" href="a00002.html">ObjAllocatorSingleton</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines type of allocator singleton, must be public to handle singleton lifetime dependencies. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b835d84fa8bc1ed3a558dc2e7a7e39ec"></a><!-- doxytag: member="Loki::SmallObjectBase::operator delete" ref="b835d84fa8bc1ed3a558dc2e7a7e39ec" args="(void *p, const std::nothrow_t &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class, class &gt; class ThreadingModel, std::size_t chunkSize, std::size_t maxSmallObjectSize, std::size_t objectAlignSize, template&lt; class &gt; class LifetimePolicy, class MutexPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="a00129.html">Loki::SmallObjectBase</a>&lt; ThreadingModel, chunkSize, maxSmallObjectSize, objectAlignSize, LifetimePolicy, MutexPolicy &gt;::operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nothrow_t &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Non-throwing single-object delete is only called when nothrow new operator is used, and the constructor throws an exception. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>SmallObj.h</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jan 29 18:51:45 2009 for Loki by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
