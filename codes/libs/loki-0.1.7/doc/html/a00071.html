<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Loki: Loki::LevelMutexInfo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="a00192.html">Loki</a>::<a class="el" href="a00071.html">LevelMutexInfo</a>
  </div>
</div>
<div class="contents">
<h1>Loki::LevelMutexInfo Class Reference</h1><!-- doxytag: class="Loki::LevelMutexInfo" --><code>#include &lt;LevelMutex.h&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Loki::LevelMutexInfo:</div>
<div class="dynsection">
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for Loki::LevelMutexInfo:</div>
<div class="dynsection">
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="a00318.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html">Checker</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">MutexUndoer</a></td></tr>

<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="76a0315d91234f5066c75660a9f27a7f"></a><!-- doxytag: member="Loki::LevelMutexInfo::MutexContainer" ref="76a0315d91234f5066c75660a9f27a7f" args="" -->
typedef ::std::vector<br class="typebreak">
&lt; volatile <a class="el" href="a00071.html">LevelMutexInfo</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#76a0315d91234f5066c75660a9f27a7f">MutexContainer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Container for locking multiple mutexes at once. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1cad7c6b6fc50e230401e4cc22761d14"></a><!-- doxytag: member="Loki::LevelMutexInfo::GetLevel" ref="1cad7c6b6fc50e230401e4cc22761d14" args="(void) const volatile" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#1cad7c6b6fc50e230401e4cc22761d14">GetLevel</a> (void) const volatile</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the level of this mutex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e6aa7465e1bba7f0c9fbf0b06f122a39"></a><!-- doxytag: member="Loki::LevelMutexInfo::IsLocked" ref="e6aa7465e1bba7f0c9fbf0b06f122a39" args="(void) const volatile" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#e6aa7465e1bba7f0c9fbf0b06f122a39">IsLocked</a> (void) const volatile</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this mutex was locked at least once. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="013e7ffd438e4c1f11dcc6943a40802e"></a><!-- doxytag: member="Loki::LevelMutexInfo::GetLockCount" ref="013e7ffd438e4c1f11dcc6943a40802e" args="(void) const volatile" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#013e7ffd438e4c1f11dcc6943a40802e">GetLockCount</a> (void) const volatile</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns count of how many times this mutex got locked. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b774e94ff72724dd87ff236d99970bb5"></a><!-- doxytag: member="Loki::LevelMutexInfo::GetPrevious" ref="b774e94ff72724dd87ff236d99970bb5" args="(void) const volatile" -->
const volatile <a class="el" href="a00071.html">LevelMutexInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#b774e94ff72724dd87ff236d99970bb5">GetPrevious</a> (void) const volatile</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointer to mutex previously locked by the thread which locked this. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual MutexErrors::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#32f89bf087b932de0cdd1151116779b4">TryLock</a> (void) volatile=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual MutexErrors::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#c0e21e08ee9974533a4da5008452bd04">Lock</a> (void) volatile=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual MutexErrors::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#5782b9fd9734d95a38ff86ef9532c89b">Lock</a> (unsigned int milliSeconds) volatile=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual MutexErrors::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#01c9af5cb0f6870585b864b4557e9242">Unlock</a> (void) volatile=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#b917108c3e7c83b8a515d28e91a3a3ca">IsRecentLock</a> (void) const volatile</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ebf33c02e3dd8adb0155fd827b5cfccd">IsRecentLock</a> (unsigned int count) const volatile</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c0a343bcb322ea36495f536504f61f9f"></a><!-- doxytag: member="Loki::LevelMutexInfo::IsLockedByCurrentThread" ref="c0a343bcb322ea36495f536504f61f9f" args="(void) const volatile" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#c0a343bcb322ea36495f536504f61f9f">IsLockedByCurrentThread</a> (void) const volatile</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this was locked by current thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7dedf2f4310f08e19c88386b4e9cd415"></a><!-- doxytag: member="Loki::LevelMutexInfo::IsLockedByAnotherThread" ref="7dedf2f4310f08e19c88386b4e9cd415" args="(void) const volatile" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#7dedf2f4310f08e19c88386b4e9cd415">IsLockedByAnotherThread</a> (void) const volatile</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this was locked by another thread. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static MutexErrors::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#dde650eae1cad8b4723e68cdb9130283">MultiLock</a> (<a class="el" href="a00071.html#76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;mutexes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static MutexErrors::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a76848d3aa8e6c66454bd5357f715583">MultiLock</a> (<a class="el" href="a00071.html#76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;mutexes, unsigned int milliSeconds)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static MutexErrors::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#475d734ba0e756935462a5151ea98065">MultiUnlock</a> (<a class="el" href="a00071.html#76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;mutexes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static const volatile <br class="typebreak">
<a class="el" href="a00071.html">LevelMutexInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#b7fd94847721b118979b72121472d3e2">GetCurrentMutex</a> (void)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#1f68bae408eb26856776cf02efed90bc">UnlockedLevel</a> = 0xFFFFFFFF</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#0e7b01d7e0aad6710f34de9811a88151">LevelMutexInfo</a> (unsigned int level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d6713a7bc49313e970c91cfeb208d0e"></a><!-- doxytag: member="Loki::LevelMutexInfo::~LevelMutexInfo" ref="5d6713a7bc49313e970c91cfeb208d0e" args="(void)" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#5d6713a7bc49313e970c91cfeb208d0e">~LevelMutexInfo</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The destructor only gets called by the derived class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#3fe2ecf1bcf2c49eae04c493f023099c">PostLock</a> (void) volatile</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7d5e2ace54e9423866be7c76116423df"></a><!-- doxytag: member="Loki::LevelMutexInfo::PreUnlock" ref="7d5e2ace54e9423866be7c76116423df" args="(void) volatile" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#7d5e2ace54e9423866be7c76116423df">PreUnlock</a> (void) volatile</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets called just before an attempt to unlock a mutex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b31292dd7d1a944b8db2ba39a8487f3b"></a><!-- doxytag: member="Loki::LevelMutexInfo::IncrementCount" ref="b31292dd7d1a944b8db2ba39a8487f3b" args="(void) volatile" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#b31292dd7d1a944b8db2ba39a8487f3b">IncrementCount</a> (void) volatile</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called to relock a mutex already locked by the current thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="929c6964d78855d487a4fd72ef8e3332"></a><!-- doxytag: member="Loki::LevelMutexInfo::DecrementCount" ref="929c6964d78855d487a4fd72ef8e3332" args="(void) volatile" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#929c6964d78855d487a4fd72ef8e3332">DecrementCount</a> (void) volatile</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called to unlock a mutex locked multiple times by the current thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#36c34ecf5d019f3db9bfb8654cf49176">IsValid</a> (void) const volatile</td></tr>

<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#01f6dfba5d2ea5606109b34e5a543cf0">IsValidList</a> (void)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This monolithic base class stores common info for a template class used to control mutexes. The template class, <a class="el" href="a00070.html">LevelMutex</a>, is policy-based class.<p>
<dl class="user" compact><dt><b>Implementation</b></dt><dd>Each thread has a list of mutexes it locked. When a mutex first gets locked, it gets added to the head of the list. If locked again, <a class="el" href="a00070.html">LevelMutex</a> merely increments a count. When unlocked, the count gets decremented until it reaches zero, and then it gets removed from the list. Each mutex has a pointer to the mutex most recently locked by the current thread. The current level of a thread is always the level of the most recently locked mutex, or UnlockedLevel if the thread does not have any mutexes locked now. A mutex is considered "recently" locked if it is at the head of the list, or the same level as the current mutex and also locked by the current thread.</dd></dl>
<dl class="user" compact><dt><b>Class Invariants</b></dt><dd>This class maintains invariants for each <a class="el" href="a00071.html">LevelMutexInfo</a> so that no function calls corrupt a mutex. Each function makes a call to IsValid at the start so that <a class="el" href="a00070.html">LevelMutex</a> knows it acts on valid internal data. Many functions call IsValid again when they return to insure the function did not leave any data in an invalid state. The exit call to IsValid occurs through a tiny helper class called <a class="el" href="a00072.html">Checker</a> to insure all data remain valid even when exceptions occur. Another helper class, <a class="el" href="a00073.html">MutexUndoer</a>, unlocks mutexes in a container if an exception occurs during calls to MultiLock.</dd></dl>
<dl class="user" compact><dt><b>Error Results</b></dt><dd>Many functions return an enum value to indicate an error status. Many enum values indicate errors detected within <a class="el" href="a00070.html">LevelMutex</a>, but some indicate errors found in policy classes, <a class="el" href="a00133.html">SpinLevelMutex</a> and <a class="el" href="a00126.html">SleepLevelMutex</a>. </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0e7b01d7e0aad6710f34de9811a88151"></a><!-- doxytag: member="Loki::LevelMutexInfo::LevelMutexInfo" ref="0e7b01d7e0aad6710f34de9811a88151" args="(unsigned int level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Loki::LevelMutexInfo::LevelMutexInfo           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the only available constructor, and it forces any derived class to set a level for each mutex. 
<p>References <a class="el" href="a00242.html#l00545">IsValid()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b7fd94847721b118979b72121472d3e2"></a><!-- doxytag: member="Loki::LevelMutexInfo::GetCurrentMutex" ref="b7fd94847721b118979b72121472d3e2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const volatile <a class="el" href="a00071.html">LevelMutexInfo</a> * Loki::LevelMutexInfo::GetCurrentMutex           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gives pointer to most recently locked mutex, or NULL if nothing locked. The pointer is for a const mutex so the mutex can't be modified inappropriately. The pointer is for a volatile mutex so callers can call volatile member functions to get info about the mutex. 
<p>References <a class="el" href="a00242.html#l00275">IsValidList()</a>.</p>

<p>Referenced by <a class="el" href="a00242.html#l00151">Loki::CountLocksInCurrentThread()</a>, <a class="el" href="a00242.html#l00165">Loki::CountMutexesAtCurrentLevel()</a>, <a class="el" href="a00242.html#l00137">Loki::CountMutexesInCurrentThread()</a>, and <a class="el" href="a00242.html#l00129">Loki::GetCurrentThreadsLevel()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="ebf33c02e3dd8adb0155fd827b5cfccd"></a><!-- doxytag: member="Loki::LevelMutexInfo::IsRecentLock" ref="ebf33c02e3dd8adb0155fd827b5cfccd" args="(unsigned int count) const volatile" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Loki::LevelMutexInfo::IsRecentLock           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const volatile</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this mutex was locked within the last count mutexes. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>How many recent mutexes to look through to find this mutex. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00242.html#l00545">IsValid()</a>, and <a class="el" href="a00243.html#l00389">m_previous</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="b917108c3e7c83b8a515d28e91a3a3ca"></a><!-- doxytag: member="Loki::LevelMutexInfo::IsRecentLock" ref="b917108c3e7c83b8a515d28e91a3a3ca" args="(void) const volatile" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Loki::LevelMutexInfo::IsRecentLock           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const volatile</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this mutex was locked by current thread, and level is the same as the current thread's level. Which means this was the most recently locked mutex, or it was locked along with several others of the same level recently. 
<p>References <a class="el" href="a00242.html#l00545">IsValid()</a>, <a class="el" href="a00243.html#l00383">m_level</a>, and <a class="el" href="a00243.html#l00389">m_previous</a>.</p>

<p>Referenced by <a class="el" href="a00242.html#l00184">Loki::DoMutexesMatchContainer()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="36c34ecf5d019f3db9bfb8654cf49176"></a><!-- doxytag: member="Loki::LevelMutexInfo::IsValid" ref="36c34ecf5d019f3db9bfb8654cf49176" args="(void) const volatile" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Loki::LevelMutexInfo::IsValid           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const volatile<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if no class invariant broken, otherwise asserts. This function only gets called in debug builds. 
<p>References <a class="el" href="a00242.html#l00275">IsValidList()</a>, and <a class="el" href="a00243.html#l00154">UnlockedLevel</a>.</p>

<p>Referenced by <a class="el" href="a00242.html#l00566">DecrementCount()</a>, <a class="el" href="a00242.html#l00557">IncrementCount()</a>, <a class="el" href="a00242.html#l00637">IsLockedByAnotherThread()</a>, <a class="el" href="a00242.html#l00575">IsLockedByCurrentThread()</a>, <a class="el" href="a00242.html#l00594">IsRecentLock()</a>, <a class="el" href="a00243.html#l00759">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;::LevelMutex()</a>, <a class="el" href="a00242.html#l00526">LevelMutexInfo()</a>, <a class="el" href="a00243.html#l00805">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;::Lock()</a>, <a class="el" href="a00242.html#l00653">PostLock()</a>, <a class="el" href="a00242.html#l00669">PreUnlock()</a>, <a class="el" href="a00243.html#l00783">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;::TryLock()</a>, <a class="el" href="a00243.html#l00861">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;::Unlock()</a>, <a class="el" href="a00243.html#l00767">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;::~LevelMutex()</a>, and <a class="el" href="a00242.html#l00536">~LevelMutexInfo()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="01f6dfba5d2ea5606109b34e5a543cf0"></a><!-- doxytag: member="Loki::LevelMutexInfo::IsValidList" ref="01f6dfba5d2ea5606109b34e5a543cf0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Loki::LevelMutexInfo::IsValidList           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if linked-list of locked mutexes in this thread is valid. Which means the list has no loops, and each previous mutex on the list has a higher or same level as the current mutex. Called by IsValid. 
<p>References <a class="el" href="a00243.html#l00383">m_level</a>, and <a class="el" href="a00243.html#l00389">m_previous</a>.</p>

<p>Referenced by <a class="el" href="a00242.html#l00267">GetCurrentMutex()</a>, <a class="el" href="a00242.html#l00545">IsValid()</a>, <a class="el" href="a00242.html#l00316">MultiLock()</a>, and <a class="el" href="a00242.html#l00479">MultiUnlock()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5782b9fd9734d95a38ff86ef9532c89b"></a><!-- doxytag: member="Loki::LevelMutexInfo::Lock" ref="5782b9fd9734d95a38ff86ef9532c89b" args="(unsigned int milliSeconds) volatile=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual MutexErrors::Type Loki::LevelMutexInfo::Lock           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>milliSeconds</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> volatile<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to lock mutex, but only waits for a limited amount of time before it gives up. Will return quickly if an error occurs before any attempt to lock. This may throw an exception if the lock failed or an error occurred - if that is what the error policy specifies. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>milliSeconds</em>&nbsp;</td><td>How long to wait. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error condition if any occurred, else Success. </dd></dl>

<p>Implemented in <a class="el" href="a00070.html#d4ac0c2a33ff3d98ec0a83f70ce145da">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="c0e21e08ee9974533a4da5008452bd04"></a><!-- doxytag: member="Loki::LevelMutexInfo::Lock" ref="c0e21e08ee9974533a4da5008452bd04" args="(void) volatile=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual MutexErrors::Type Loki::LevelMutexInfo::Lock           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> volatile<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Blocking call will attempt to lock mutex and wait until it can lock. This may throw an exception if the lock failed or an error occurred - if that is what the error policy specifies. <dl class="return" compact><dt><b>Returns:</b></dt><dd>An error condition if any occurred, else Success. </dd></dl>

<p>Implemented in <a class="el" href="a00070.html#95d3742db062548201986f482a9c9b9d">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;</a>.</p>

<p>Referenced by <a class="el" href="a00242.html#l01045">Loki::MutexLocker::Lock()</a>, and <a class="el" href="a00242.html#l00997">Loki::MutexLocker::MutexLocker()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a76848d3aa8e6c66454bd5357f715583"></a><!-- doxytag: member="Loki::LevelMutexInfo::MultiLock" ref="a76848d3aa8e6c66454bd5357f715583" args="(MutexContainer &amp;mutexes, unsigned int milliSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MutexErrors::Type Loki::LevelMutexInfo::MultiLock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00071.html#76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mutexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>milliSeconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks several mutexes at once. Requires O(m + n*n + n*t) actions where m is the number of mutexes currently locked by the thread, n is the number of mutexes in the container, and t is the wait time for each mutex. This provides strong exception safety. If an exception occurs, any mutexes that were locked during this call will ge unlocked. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutexes</em>&nbsp;</td><td>Container of pointers to mutexes. Container must have at least 1 mutex, all mutexes must have the same level, no NULL pointers, and all mutexes must not exceed the thread's current level. This sorts the container by address order. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>milliSeconds</em>&nbsp;</td><td>Amount of time to wait for each mutex. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Enum value indicating success or error. </dd></dl>

<p>References <a class="el" href="a00242.html#l00259">Loki::LevelMutexInfo::LevelMutexInfo::MutexUndoer::Cancel()</a>, DoErrorCheck(), <a class="el" href="a00242.html#l00184">Loki::DoMutexesMatchContainer()</a>, <a class="el" href="a00242.html#l00129">Loki::GetCurrentThreadsLevel()</a>, <a class="el" href="a00242.html#l00275">IsValidList()</a>, <a class="el" href="a00242.html#l00316">MultiLock()</a>, <a class="el" href="a00242.html#l00251">Loki::LevelMutexInfo::LevelMutexInfo::MutexUndoer::SetPlace()</a>, and <a class="el" href="a00243.html#l00154">UnlockedLevel</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="dde650eae1cad8b4723e68cdb9130283"></a><!-- doxytag: member="Loki::LevelMutexInfo::MultiLock" ref="dde650eae1cad8b4723e68cdb9130283" args="(MutexContainer &amp;mutexes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MutexErrors::Type Loki::LevelMutexInfo::MultiLock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00071.html#76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mutexes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks several mutexes at once. Requires O(m + n*n) actions where m is the number of mutexes currently locked by the thread and n is the number of mutexes in the container. This provides strong exception safety. If an exception occurs, any mutexes that were locked during this call will get unlocked. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutexes</em>&nbsp;</td><td>Container of pointers to mutexes. Container must have at least 1 mutex, all mutexes must have the same level, no NULL pointers, and all mutexes must not exceed the thread's current level. This sorts the container by address order. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Enum value indicating success or error. </dd></dl>

<p>References <a class="el" href="a00242.html#l00259">Loki::LevelMutexInfo::LevelMutexInfo::MutexUndoer::Cancel()</a>, DoErrorCheck(), <a class="el" href="a00242.html#l00184">Loki::DoMutexesMatchContainer()</a>, <a class="el" href="a00242.html#l00129">Loki::GetCurrentThreadsLevel()</a>, <a class="el" href="a00242.html#l00275">IsValidList()</a>, <a class="el" href="a00242.html#l00251">Loki::LevelMutexInfo::LevelMutexInfo::MutexUndoer::SetPlace()</a>, and <a class="el" href="a00243.html#l00154">UnlockedLevel</a>.</p>

<p>Referenced by <a class="el" href="a00242.html#l01124">Loki::MultiMutexLocker::Lock()</a>, <a class="el" href="a00242.html#l00396">MultiLock()</a>, and <a class="el" href="a00242.html#l01073">Loki::MultiMutexLocker::MultiMutexLocker()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="475d734ba0e756935462a5151ea98065"></a><!-- doxytag: member="Loki::LevelMutexInfo::MultiUnlock" ref="475d734ba0e756935462a5151ea98065" args="(MutexContainer &amp;mutexes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MutexErrors::Type Loki::LevelMutexInfo::MultiUnlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00071.html#76a0315d91234f5066c75660a9f27a7f">MutexContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mutexes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlocks several mutexes at once. Requires O(m) actions where m is the number of mutexes in the container. This provides strong exception safety. If an exception occurs when unlocking one mutex, other mutexes in the container get unlocked anyway. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutexes</em>&nbsp;</td><td>Container of pointers to mutexes. Container must have at least 1 mutex, all mutexes must have the same level, no NULL pointers, and all mutexes must be locked by the current thread. This sorts the container dby address order. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Enum value indicating success or error. </dd></dl>

<p>References DoErrorCheck(), <a class="el" href="a00242.html#l00184">Loki::DoMutexesMatchContainer()</a>, <a class="el" href="a00242.html#l00275">IsValidList()</a>, <a class="el" href="a00243.html#l00154">UnlockedLevel</a>, and UnlockThis().</p>

<p>Referenced by <a class="el" href="a00242.html#l01138">Loki::MultiMutexLocker::Unlock()</a>, and <a class="el" href="a00242.html#l01107">Loki::MultiMutexLocker::~MultiMutexLocker()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="3fe2ecf1bcf2c49eae04c493f023099c"></a><!-- doxytag: member="Loki::LevelMutexInfo::PostLock" ref="3fe2ecf1bcf2c49eae04c493f023099c" args="(void) volatile" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Loki::LevelMutexInfo::PostLock           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> volatile<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This gets called after each call to DoLock and DoTryLock to make sure the data members in this object get set correctly. 
<p>References <a class="el" href="a00242.html#l00575">IsLockedByCurrentThread()</a>, and <a class="el" href="a00242.html#l00545">IsValid()</a>.</p>

<p>Referenced by <a class="el" href="a00243.html#l00805">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;::Lock()</a>, <a class="el" href="a00243.html#l00783">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;::TryLock()</a>, and <a class="el" href="a00243.html#l00861">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;::Unlock()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="32f89bf087b932de0cdd1151116779b4"></a><!-- doxytag: member="Loki::LevelMutexInfo::TryLock" ref="32f89bf087b932de0cdd1151116779b4" args="(void) volatile=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual MutexErrors::Type Loki::LevelMutexInfo::TryLock           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> volatile<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to lock mutex, and returns immediately if mutex already locked by another thread. It will return immediately with a value of AlreadyLocked if the mutex was locked by a different thread. It may throw an exception or assert when errors occur if the ErrorPolicy class implements that behavior. <dl class="return" compact><dt><b>Returns:</b></dt><dd>An error condition if any occurred, else Success. </dd></dl>

<p>Implemented in <a class="el" href="a00070.html#042a7938dafd6f149cfd7da46478c0c9">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="01c9af5cb0f6870585b864b4557e9242"></a><!-- doxytag: member="Loki::LevelMutexInfo::Unlock" ref="01c9af5cb0f6870585b864b4557e9242" args="(void) volatile=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual MutexErrors::Type Loki::LevelMutexInfo::Unlock           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> volatile<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlocks the mutex, or returns an error condition. This may throw an exception if the lock failed or an error occurred - if that is what the error policy specifies. <dl class="return" compact><dt><b>Returns:</b></dt><dd>An error condition if any occurred, else Success. </dd></dl>

<p>Implemented in <a class="el" href="a00070.html#553a379257af57ceaef9ed48b0dc8b70">Loki::LevelMutex&lt; MutexPolicy, DefaultLevel, ErrorPolicy, WaitPolicy &gt;</a>.</p>

<p>Referenced by <a class="el" href="a00242.html#l01059">Loki::MutexLocker::Unlock()</a>, and <a class="el" href="a00242.html#l01028">Loki::MutexLocker::~MutexLocker()</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="1f68bae408eb26856776cf02efed90bc"></a><!-- doxytag: member="Loki::LevelMutexInfo::UnlockedLevel" ref="1f68bae408eb26856776cf02efed90bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="a00071.html#1f68bae408eb26856776cf02efed90bc">Loki::LevelMutexInfo::UnlockedLevel</a> = 0xFFFFFFFF<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Level for thread that has not locked any mutex. Maximum possible level for a mutex is UnlockedLevel-1; No mutex may have a level of UnlockedLevel. 
<p>Referenced by <a class="el" href="a00242.html#l00184">Loki::DoMutexesMatchContainer()</a>, <a class="el" href="a00242.html#l00129">Loki::GetCurrentThreadsLevel()</a>, <a class="el" href="a00242.html#l00545">IsValid()</a>, <a class="el" href="a00242.html#l00316">MultiLock()</a>, and <a class="el" href="a00242.html#l00479">MultiUnlock()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00158.html">LevelMutex.h</a><li><a class="el" href="a00157.html">LevelMutex.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jan 29 18:51:42 2009 for Loki by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
